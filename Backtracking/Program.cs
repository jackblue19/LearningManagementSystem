/*
//using System;
//using System.Collections.Generic;
//using System.Linq;

//namespace Backtracking
//{
//    // ===== Config (khớp DB: TimeSlots, Rooms, StartDate/EndDate, MinGapDays) =====
//    public sealed class TimeSlotDef
//    {
//        public byte SlotId { get; init; }
//        public string Label { get; init; } = "";
//        public TimeOnly Start { get; init; }
//        public TimeOnly End { get; init; }
//    }

//    public sealed class Config
//    {
//        public required List<TimeSlotDef> TimeSlots { get; init; }   // index = SlotId
//        public required int Rooms { get; init; }                      // 1..63 (mặc định)
//        public required int DaysTotal { get; init; }                  // EndDate - StartDate + 1
//        public required int StartDow { get; init; }                   // 0=Mon..6=Sun
//        public required int MinGapDays { get; init; }                 // ≥2 mặc định
//        public required DateOnly StartDate { get; init; }             // dùng để in SessionDate
//    }

//    // ===== Input bài toán (khớp với DB Hybrid) =====
//    public sealed class ClassInfo
//    {
//        public int Id { get; init; }          // Classes.ClassId (minh hoạ: int)
//        public int SessionsPerWeek { get; init; }  // 2|3|...
//        public int TeacherId { get; init; }   // Users.UserId (minh hoạ: int)
//    }

//    // Slot encode 32-bit: [dayIdx<<9 | slot<<6 | room]  (day<=~8M, slot<=7, room<=63)
//    public readonly struct SlotCode : IEquatable<SlotCode>
//    {
//        public readonly uint Code;
//        public SlotCode(uint code) => Code = code;
//        public static SlotCode Encode(int dayIdx, int slot, int room)
//            => new((uint)((dayIdx << 9) | (slot << 6) | room));
//        public int DayIdx => (int)(Code >> 9);
//        public int SlotIdx => (int)((Code >> 6) & 0x7);
//        public int Room => (int)(Code & 0x3F);
//        public bool Equals(SlotCode other) => Code == other.Code;
//        public override bool Equals(object? obj) => obj is SlotCode sc && Equals(sc);
//        public override int GetHashCode() => (int)Code;
//        public override string ToString() => $"[d:{DayIdx} s:{SlotIdx} r:{Room}]";
//    }

//    public sealed class Problem
//    {
//        public required List<ClassInfo> Classes { get; init; }
//        public HashSet<SlotCode> GlobalBlock { get; } = new();
//        public Dictionary<int, HashSet<SlotCode>> ClassBlock { get; } = new();   // ClassId -> blocked SlotCode
//        public Dictionary<int, HashSet<SlotCode>> TeacherBlock { get; } = new(); // TeacherId -> blocked SlotCode
//    }

//    // ===== Output map về DB ClassSchedules =====
//    public sealed class ScheduleRow
//    {
//        public int ClassId { get; init; }
//        public DateOnly SessionDate { get; init; } // = StartDate + dayIdx
//        public byte SlotId { get; init; }          // FK TimeSlots
//        public Guid RoomId { get; init; }          // minh hoạ: map từ room index -> Guid
//        public bool IsAutoGenerated { get; init; } = true;
//        public TimeOnly StartTime { get; init; }   // từ TimeSlots
//        public TimeOnly EndTime { get; init; }     // từ TimeSlots
//        public string RoomName { get; init; } = ""; // nếu cần fill
//    }

//    // ===== Solver (MRV + LCV + Forward-Checking) =====
//    public sealed class Scheduler
//    {
//        private readonly Config _cfg;
//        private readonly Problem _pb;

//        private readonly Dictionary<int, List<SlotCode>> _chosen = new();
//        private readonly HashSet<SlotCode> _used = new();
//        private readonly Dictionary<int, HashSet<SlotCode>> _busyTeacher = new(); // TeacherId -> using slots
//        private List<int> _order = new();                                          // class order (MRV)

//        public Dictionary<int, List<SlotCode>> Best { get; private set; } = new();

//        public Scheduler(Config cfg, Problem pb)
//        {
//            _cfg = cfg;
//            _pb = pb;

//            foreach (var c in pb.Classes)
//            {
//                _chosen[c.Id] = new List<SlotCode>();
//                _busyTeacher.TryAdd(c.TeacherId, new HashSet<SlotCode>());
//                _pb.ClassBlock.TryAdd(c.Id, new HashSet<SlotCode>());
//                _pb.TeacherBlock.TryAdd(c.TeacherId, new HashSet<SlotCode>());
//            }
//        }

//        public bool Solve()
//        {
//            var pool = _pb.Classes.Select(c => c.Id).ToList();
//            return Dfs(pool);
//        }

//        private static int DowAdd(int startDow, int dayIdx) => (startDow + dayIdx) % 7; // 0..6

//        private bool GapOk(int d1, int d2) => Math.Abs(d2 - d1) >= _cfg.MinGapDays;

//        private bool ClassGapOk(List<SlotCode> cur, int day)
//        {
//            for (int i = 0; i < cur.Count; i++)
//                if (!GapOk(cur[i].DayIdx, day)) return false;
//            return true;
//        }

//        private int Need(int cid) => _pb.Classes.First(c => c.Id == cid).SessionsPerWeek;

//        private int TeacherOf(int cid) => _pb.Classes.First(c => c.Id == cid).TeacherId;

//        private List<SlotCode> Domain(int cid, int teacher)
//        {
//            var dom = new List<SlotCode>();
//            var blkClass = _pb.ClassBlock[cid];

//            for (int d = 0; d < _cfg.DaysTotal; d++)
//            {
//                if (!ClassGapOk(_chosen[cid], d)) continue;

//                for (int s = 0; s < _cfg.TimeSlots.Count; s++)
//                {
//                    for (int r = 0; r < _cfg.Rooms; r++)
//                    {
//                        var sc = SlotCode.Encode(d, s, r);
//                        if (_pb.GlobalBlock.Contains(sc)) continue;
//                        if (blkClass.Contains(sc)) continue;
//                        if (_pb.TeacherBlock[teacher].Contains(sc)) continue;
//                        if (_busyTeacher[teacher].Contains(sc)) continue;
//                        if (_used.Contains(sc)) continue;
//                        dom.Add(sc);
//                    }
//                }
//            }
//            return dom;
//        }

//        private int ConflictScore(SlotCode sc, IReadOnlyList<int> remaining)
//        {
//            int cnt = 0;
//            foreach (var cid in remaining)
//            {
//                var t = TeacherOf(cid);
//                if (_pb.ClassBlock[cid].Contains(sc)) continue;
//                if (_busyTeacher[t].Contains(sc)) continue;
//                if (_pb.TeacherBlock[t].Contains(sc)) continue;
//                cnt++;
//            }
//            return cnt;
//        }

//        private bool ForwardOk(IReadOnlyList<int> rem)
//        {
//            foreach (var cid in rem)
//            {
//                var t = TeacherOf(cid);
//                var dom = Domain(cid, t);
//                if (dom.Count + _chosen[cid].Count < Need(cid)) return false;
//            }
//            return true;
//        }

//        private void BuildOrder(List<int> pool)
//        {
//            _order = pool.Select(cid =>
//            {
//                var t = TeacherOf(cid);
//                var dsz = Domain(cid, t).Count;
//                return (cid, dsz);
//            })
//            .OrderBy(p => p.dsz)
//            .Select(p => p.cid)
//            .ToList();
//        }

//        private bool Dfs(List<int> pool)
//        {
//            if (pool.Count == 0)
//            {
//                Best = _chosen.ToDictionary(kv => kv.Key, kv => kv.Value.ToList());
//                return true;
//            }

//            BuildOrder(pool);
//            int cid = _order[0];
//            int tid = TeacherOf(cid);

//            var dom = Domain(cid, tid);
//            if (dom.Count + _chosen[cid].Count < Need(cid)) return false;

//            var rest = pool.Where(x => x != cid).ToList();
//            dom.Sort((a, b) => ConflictScore(a, rest).CompareTo(ConflictScore(b, rest)));

//            foreach (var sc in dom)
//            {
//                _chosen[cid].Add(sc);
//                _used.Add(sc);
//                _busyTeacher[tid].Add(sc);

//                bool done = _chosen[cid].Count == Need(cid);
//                var nextPool = pool;
//                if (done) nextPool = pool.Where(x => x != cid).ToList();

//                if (ForwardOk(nextPool) && Dfs(nextPool)) return true;

//                _chosen[cid].RemoveAt(_chosen[cid].Count - 1);
//                _used.Remove(sc);
//                _busyTeacher[tid].Remove(sc);
//            }
//            return false;
//        }
//    }

//    // ===== Helpers: dựng block từ “danh sách slot cho phép” theo DOW =====
//    public static class BlockBuilder
//    {
//        // tạo GlobalBlock bằng cách khóa tất cả slot KHÔNG thuộc “allowedByDow”
//        // allowedByDow: key = dow(0..6), value = danh sách slotIdx cho phép
//        public static void ApplyGlobalBlocksFromAllowed(
//            Problem pb, Config cfg, Dictionary<int, HashSet<int>> allowedByDow)
//        {
//            for (int d = 0; d < cfg.DaysTotal; d++)
//            {
//                int dow = (cfg.StartDow + d) % 7;
//                var allowed = allowedByDow.TryGetValue(dow, out var set) ? set : new HashSet<int>();
//                for (int s = 0; s < cfg.TimeSlots.Count; s++)
//                {
//                    bool ok = allowed.Contains(s);
//                    if (!ok)
//                    {
//                        for (int r = 0; r < cfg.Rooms; r++)
//                            pb.GlobalBlock.Add(SlotCode.Encode(d, s, r));
//                    }
//                }
//            }
//        }

//        // tạo block cho giáo viên theo DOW + slot cho phép (nếu cần)
//        public static void ApplyTeacherAllowed(
//            Problem pb, Config cfg, int teacherId, Dictionary<int, HashSet<int>> allowedByDow)
//        {
//            if (!pb.TeacherBlock.ContainsKey(teacherId)) pb.TeacherBlock[teacherId] = new HashSet<SlotCode>();
//            var blk = pb.TeacherBlock[teacherId];

//            for (int d = 0; d < cfg.DaysTotal; d++)
//            {
//                int dow = (cfg.StartDow + d) % 7;
//                var allowed = allowedByDow.TryGetValue(dow, out var set) ? set : new HashSet<int>();
//                for (int s = 0; s < cfg.TimeSlots.Count; s++)
//                {
//                    bool ok = allowed.Contains(s);
//                    if (!ok)
//                    {
//                        for (int r = 0; r < cfg.Rooms; r++)
//                            blk.Add(SlotCode.Encode(d, s, r));
//                    }
//                }
//            }
//        }
//    }

//    // ===== Program (3 test cases) =====
//    public static class Program
//    {
//        public static void Main()
//        {
//            Console.OutputEncoding = System.Text.Encoding.UTF8;

//            // TimeSlots (khớp DB)
//            var timeSlots = new List<TimeSlotDef>
//            {
//                new() { SlotId = 0, Label = "07-09", Start = new(7,0), End = new(9,0) },
//                new() { SlotId = 1, Label = "09-11", Start = new(9,0), End = new(11,0) },
//                new() { SlotId = 2, Label = "13-15", Start = new(13,0), End = new(15,0) },
//                new() { SlotId = 3, Label = "15-17", Start = new(15,0), End = new(17,0) },
//                new() { SlotId = 4, Label = "17-19", Start = new(17,0), End = new(19,0) },
//                new() { SlotId = 5, Label = "19-21", Start = new(19,0), End = new(21,0) },
//            };

//            // ======= TEST CASE 1 =======
//            Console.WriteLine("=== TEST CASE 1: 1 room, 1 teacher, 8 classes, 1 week (MinGap=2) ===");
//            var cfg1 = new Config
//            {
//                TimeSlots = timeSlots,
//                Rooms = 1,
//                DaysTotal = 7,
//                StartDow = 0, // Monday
//                MinGapDays = 2,
//                StartDate = new DateOnly(2025, 10, 06)
//            };

//            var classes1 = new List<ClassInfo>();
//            for (int i = 1; i <= 8; i++) classes1.Add(new ClassInfo { Id = i, SessionsPerWeek = 2, TeacherId = 1 });

//            var pb1 = new Problem { Classes = classes1 };

//            var allowedByDow1 = new Dictionary<int, HashSet<int>>
//            {
//                // Mon..Sat: only 17-19(4), 19-21(5)
//                { 0, new HashSet<int>{4,5} }, { 1, new HashSet<int>{4,5} }, { 2, new HashSet<int>{4,5} },
//                { 3, new HashSet<int>{4,5} }, { 4, new HashSet<int>{4,5} }, { 5, new HashSet<int>{4,5} },
//                // Sun: 07-09(0), 09-11(1), 15-17(3), 17-19(4), 19-21(5)
//                { 6, new HashSet<int>{0,1,3,4,5} }
//            };
//            BlockBuilder.ApplyGlobalBlocksFromAllowed(pb1, cfg1, allowedByDow1);

//            var result1 = RunAndPrint("CASE 1", cfg1, pb1);
//            Console.WriteLine();

//            // ======= TEST CASE 2 =======
//            Console.WriteLine("=== TEST CASE 2: 4 weeks, 4 rooms, 10 classes / 3 teachers (MinGap=2) ===");
//            var cfg2 = new Config
//            {
//                TimeSlots = timeSlots,
//                Rooms = 4,
//                DaysTotal = 28, // 4 weeks
//                StartDow = 0,
//                MinGapDays = 2,
//                StartDate = new DateOnly(2025, 10, 06)
//            };

//            var classes2 = new List<ClassInfo>();
//            for (int i = 1; i <= 10; i++)
//            {
//                int teacher = (i % 3) + 1; // 1..3
//                classes2.Add(new ClassInfo { Id = i, SessionsPerWeek = 3, TeacherId = teacher });
//            }
//            var pb2 = new Problem { Classes = classes2 };

//            // Teacher 2 bận Wed(2) slot 1 mỗi tuần; Teacher 3 bận Fri(4) slot 0 mỗi tuần
//            var teacher2Allowed = new Dictionary<int, HashSet<int>>
//            {
//                { 2, new HashSet<int>{0,2,3,4,5} } // cho phép mọi slot trừ 1
//            };
//            var teacher3Allowed = new Dictionary<int, HashSet<int>>
//            {
//                { 4, new HashSet<int>{1,2,3,4,5} } // cho phép mọi slot trừ 0
//            };
//            BlockBuilder.ApplyTeacherAllowed(pb2, cfg2, 2, teacher2Allowed);
//            BlockBuilder.ApplyTeacherAllowed(pb2, cfg2, 3, teacher3Allowed);

//            var result2 = RunAndPrint("CASE 2", cfg2, pb2);
//            Console.WriteLine();

//            // ======= TEST CASE 3 =======
//            Console.WriteLine("=== TEST CASE 3: 1 room, 3 teachers, 6 classes, custom blocks (MinGap=2) ===");
//            var cfg3 = new Config
//            {
//                TimeSlots = timeSlots,
//                Rooms = 1,
//                DaysTotal = 14, // 2 weeks
//                StartDow = 1,   // Tuesday
//                MinGapDays = 2,
//                StartDate = new DateOnly(2025, 10, 07)
//            };
//            var classes3 = new List<ClassInfo>
//            {
//                new() { Id = 1, SessionsPerWeek = 2, TeacherId = 10 },
//                new() { Id = 2, SessionsPerWeek = 2, TeacherId = 10 },
//                new() { Id = 3, SessionsPerWeek = 2, TeacherId = 11 },
//                new() { Id = 4, SessionsPerWeek = 2, TeacherId = 11 },
//                new() { Id = 5, SessionsPerWeek = 2, TeacherId = 12 },
//                new() { Id = 6, SessionsPerWeek = 2, TeacherId = 12 },
//            };
//            var pb3 = new Problem { Classes = classes3 };

//            // Global: khóa toàn bộ slot 0 và 1 cho mọi ngày (chỉ học từ chiều tối)
//            for (int d = 0; d < cfg3.DaysTotal; d++)
//                for (int r = 0; r < cfg3.Rooms; r++)
//                {
//                    pb3.GlobalBlock.Add(SlotCode.Encode(d, 0, r));
//                    pb3.GlobalBlock.Add(SlotCode.Encode(d, 1, r));
//                }

//            // Class 1 bị block slot 4 toàn bộ (không học 17-19)
//            pb3.ClassBlock[1] = new HashSet<SlotCode>();
//            for (int d = 0; d < cfg3.DaysTotal; d++)
//                pb3.ClassBlock[1].Add(SlotCode.Encode(d, 4, 0));

//            // Teacher 12 không dạy Chủ nhật (dow=6) mọi slot
//            pb3.TeacherBlock[12] = new HashSet<SlotCode>();
//            for (int d = 0; d < cfg3.DaysTotal; d++)
//            {
//                int dow = (cfg3.StartDow + d) % 7;
//                if (dow == 6)
//                    for (int s = 0; s < cfg3.TimeSlots.Count; s++)
//                        pb3.TeacherBlock[12].Add(SlotCode.Encode(d, s, 0));
//            }

//            var result3 = RunAndPrint("CASE 3", cfg3, pb3);
//            Console.WriteLine();

//            // In tóm tắt pass/fail ba case
//            Console.WriteLine("SUMMARY:");
//            Console.WriteLine($"Case1: {(result1 ? "OK" : "FAIL")}");
//            Console.WriteLine($"Case2: {(result2 ? "OK" : "FAIL")}");
//            Console.WriteLine($"Case3: {(result3 ? "OK" : "FAIL")}");
//        }

//        private static bool RunAndPrint(string title, Config cfg, Problem pb)
//        {
//            var sch = new Scheduler(cfg, pb);
//            var ok = sch.Solve();

//            if (!ok)
//            {
//                Console.WriteLine($"[{title}] Không lập được lịch.");
//                return false;
//            }

//            // Giả lập RoomId/RoomName từ room index
//            Guid RoomGuidOf(int roomIdx) => GuidUtility.Create(GuidUtility.UrlNamespace, $"room-{roomIdx + 1}");
//            string RoomNameOf(int roomIdx) => $"Room {roomIdx + 1}";

//            // Chuyển Best -> ScheduleRows (khớp DB ClassSchedules)
//            var rows = new List<ScheduleRow>();
//            foreach (var (cid, slots) in sch.Best.OrderBy(k => k.Key))
//            {
//                foreach (var sc in slots.OrderBy(s => s.DayIdx).ThenBy(s => s.SlotIdx))
//                {
//                    var ts = cfg.TimeSlots[sc.SlotIdx];
//                    rows.Add(new ScheduleRow
//                    {
//                        ClassId = cid,
//                        SessionDate = cfg.StartDate.AddDays(sc.DayIdx),
//                        SlotId = ts.SlotId,
//                        RoomId = RoomGuidOf(sc.Room),
//                        IsAutoGenerated = true,
//                        StartTime = ts.Start,
//                        EndTime = ts.End,
//                        RoomName = RoomNameOf(sc.Room)
//                    });
//                }
//            }

//            Console.WriteLine($"[{title}] Lập lịch thành công. Tổng buổi: {rows.Count}");
//            foreach (var g in rows.GroupBy(r => r.ClassId).OrderBy(g => g.Key))
//            {
//                Console.WriteLine($"  Lớp {g.Key}:");
//                foreach (var r in g)
//                    Console.WriteLine($"    • {r.SessionDate:yyyy-MM-dd}  Slot#{r.SlotId} ({r.StartTime}-{r.EndTime})  {r.RoomName}");
//            }
//            return true;
//        }
//    }

//    // ===== Deterministic Guid for demo (so output roomId stable) =====
//    // Credit: RFC 4122 name-based UUID v5 simplified
//    public static class GuidUtility
//    {
//        public static readonly Guid UrlNamespace = new("6ba7b811-9dad-11d1-80b4-00c04fd430c8");

//        public static Guid Create(Guid namespaceId, string name)
//        {
//            var ns = namespaceId.ToByteArray();
//            SwapByteOrder(ns);
//            var nameBytes = System.Text.Encoding.UTF8.GetBytes(name);
//            var data = new byte[ns.Length + nameBytes.Length];
//            Buffer.BlockCopy(ns, 0, data, 0, ns.Length);
//            Buffer.BlockCopy(nameBytes, 0, data, ns.Length, nameBytes.Length);
//            var sha1 = System.Security.Cryptography.SHA1.HashData(data);
//            var newGuid = new byte[16];
//            Array.Copy(sha1, 0, newGuid, 0, 16);
//            newGuid[6] = (byte)((newGuid[6] & 0x0F) | (5 << 4));  // version 5
//            newGuid[8] = (byte)((newGuid[8] & 0x3F) | 0x80);      // variant
//            SwapByteOrder(newGuid);
//            return new Guid(newGuid);
//        }

//        private static void SwapByteOrder(byte[] guid)
//        {
//            void Swap(int a, int b) { (guid[a], guid[b]) = (guid[b], guid[a]); }
//            Swap(0, 3); Swap(1, 2);
//            Swap(4, 5); Swap(6, 7);
//        }
//    }
//}
*/
/*
using System;
using System.Collections.Generic;
using System.Linq;

namespace Backtracking
{
    // ===== Config (khớp DB Hybrid: TimeSlots / Rooms / MinGapDays / StartDate) =====
    public sealed class TimeSlotDef
    {
        public byte SlotId { get; init; }
        public string Label { get; init; } = "";
        public TimeOnly Start { get; init; }
        public TimeOnly End { get; init; }
    }

    public sealed class Config
    {
        public required List<TimeSlotDef> TimeSlots { get; init; }   // index = SlotId
        public required int Rooms { get; init; }                      // 1..63
        public required int DaysTotal { get; init; }                  // EndDate - StartDate + 1
        public required int StartDow { get; init; }                   // 0=Mon..6=Sun
        public required int MinGapDays { get; init; }                 // ≥2
        public required DateOnly StartDate { get; init; }             // để in SessionDate
    }

    // ===== Input bài toán (khớp với DB Hybrid) =====
    public sealed class ClassInfo
    {
        public int Id { get; init; }                 // Classes.ClassId (minh hoạ: int)
        public int SessionsPerWeek { get; init; }    // 2|3|...
        public int TeacherId { get; init; }          // Users.UserId (minh hoạ: int)
    }

    // Slot encode 32-bit: [dayIdx<<9 | slot<<6 | room]  (day<=~8M, slot<=7, room<=63)
    public readonly struct SlotCode : IEquatable<SlotCode>
    {
        public readonly uint Code;
        public SlotCode(uint code) => Code = code;
        public static SlotCode Encode(int dayIdx, int slot, int room)
            => new((uint)((dayIdx << 9) | (slot << 6) | room));
        public int DayIdx => (int)(Code >> 9);
        public int SlotIdx => (int)((Code >> 6) & 0x7);
        public int Room => (int)(Code & 0x3F);
        public bool Equals(SlotCode other) => Code == other.Code;
        public override bool Equals(object? obj) => obj is SlotCode sc && Equals(sc);
        public override int GetHashCode() => (int)Code;
        public override string ToString() => $"[d:{DayIdx} s:{SlotIdx} r:{Room}]";
    }

    public sealed class Problem
    {
        public required List<ClassInfo> Classes { get; init; }
        public HashSet<SlotCode> GlobalBlock { get; } = new();
        public Dictionary<int, HashSet<SlotCode>> ClassBlock { get; } = new();   // ClassId -> blocked SlotCode
        public Dictionary<int, HashSet<SlotCode>> TeacherBlock { get; } = new(); // TeacherId -> blocked SlotCode (room-specific)
    }

    // ===== Output map về DB ClassSchedules =====
    public sealed class ScheduleRow
    {
        public int ClassId { get; init; }
        public DateOnly SessionDate { get; init; } // = StartDate + dayIdx
        public byte SlotId { get; init; }          // FK TimeSlots
        public Guid RoomId { get; init; }          // minh hoạ: map từ room index -> Guid
        public bool IsAutoGenerated { get; init; } = true;
        public TimeOnly StartTime { get; init; }   // từ TimeSlots
        public TimeOnly EndTime { get; init; }     // từ TimeSlots
        public string RoomName { get; init; } = ""; // nếu cần fill
    }

    // ===== Solver (MRV + LCV + Forward-Checking) =====
    public sealed class Scheduler
    {
        private readonly Config _cfg;
        private readonly Problem _pb;

        private readonly Dictionary<int, List<SlotCode>> _chosen = new();
        private readonly HashSet<SlotCode> _used = new();

        // Giáo viên bận theo slot *cụ thể* (có room) – giữ lại cho an toàn
        private readonly Dictionary<int, HashSet<SlotCode>> _busyTeacher = new(); // teacher -> using slots (room-specific)

        // 🔧 FIX: Giáo viên bận theo (day,slot) bất kể phòng
        private readonly Dictionary<int, HashSet<int>> _busyTeacherDaySlot = new(); // teacher -> (day<<8)|slot
        private static int DaySlotKey(int dayIdx, int slotIdx) => (dayIdx << 8) | slotIdx;

        private List<int> _order = new(); // class order (MRV)

        public Dictionary<int, List<SlotCode>> Best { get; private set; } = new();

        public Scheduler(Config cfg, Problem pb)
        {
            _cfg = cfg;
            _pb = pb;

            foreach (var c in pb.Classes)
            {
                _chosen[c.Id] = new List<SlotCode>();
                _busyTeacher.TryAdd(c.TeacherId, new HashSet<SlotCode>());
                _busyTeacherDaySlot.TryAdd(c.TeacherId, new HashSet<int>()); // init
                _pb.ClassBlock.TryAdd(c.Id, new HashSet<SlotCode>());
                _pb.TeacherBlock.TryAdd(c.TeacherId, new HashSet<SlotCode>());
            }
        }

        public bool Solve()
        {
            var pool = _pb.Classes.Select(c => c.Id).ToList();
            return Dfs(pool);
        }

        private bool GapOk(int d1, int d2) => Math.Abs(d2 - d1) >= _cfg.MinGapDays;

        private bool ClassGapOk(List<SlotCode> cur, int day)
        {
            for (int i = 0; i < cur.Count; i++)
                if (!GapOk(cur[i].DayIdx, day)) return false;
            return true;
        }

        private int Need(int cid) => _pb.Classes.First(c => c.Id == cid).SessionsPerWeek;

        private int TeacherOf(int cid) => _pb.Classes.First(c => c.Id == cid).TeacherId;

        private List<SlotCode> Domain(int cid, int teacher)
        {
            var dom = new List<SlotCode>();
            var blkClass = _pb.ClassBlock[cid];

            for (int d = 0; d < _cfg.DaysTotal; d++)
            {
                if (!ClassGapOk(_chosen[cid], d)) continue;

                for (int s = 0; s < _cfg.TimeSlots.Count; s++)
                {
                    // 🔧 FIX: chặn giáo viên trùng (ngày,slot) bất kể phòng
                    int dsKey = DaySlotKey(d, s);
                    if (_busyTeacherDaySlot[teacher].Contains(dsKey)) continue;

                    for (int r = 0; r < _cfg.Rooms; r++)
                    {
                        var sc = SlotCode.Encode(d, s, r);
                        if (_pb.GlobalBlock.Contains(sc)) continue;
                        if (blkClass.Contains(sc)) continue;
                        if (_pb.TeacherBlock[teacher].Contains(sc)) continue; // teacher rule (room-level blocks)
                        if (_busyTeacher[teacher].Contains(sc)) continue;     // keep
                        if (_used.Contains(sc)) continue;
                        dom.Add(sc);
                    }
                }
            }
            return dom;
        }

        private int ConflictScore(SlotCode sc, IReadOnlyList<int> remaining)
        {
            int cnt = 0;
            foreach (var cid in remaining)
            {
                var t = TeacherOf(cid);
                if (_pb.ClassBlock[cid].Contains(sc)) continue;
                if (_busyTeacher[t].Contains(sc)) continue;
                if (_pb.TeacherBlock[t].Contains(sc)) continue;
                // coi như có thể xung đột
                cnt++;
            }
            return cnt;
        }

        private bool ForwardOk(IReadOnlyList<int> rem)
        {
            foreach (var cid in rem)
            {
                var t = TeacherOf(cid);
                var dom = Domain(cid, t);
                if (dom.Count + _chosen[cid].Count < Need(cid)) return false;
            }
            return true;
        }

        private void BuildOrder(List<int> pool)
        {
            _order = pool.Select(cid =>
            {
                var t = TeacherOf(cid);
                var dsz = Domain(cid, t).Count;
                return (cid, dsz);
            })
            .OrderBy(p => p.dsz)
            .Select(p => p.cid)
            .ToList();
        }

        private bool Dfs(List<int> pool)
        {
            if (pool.Count == 0)
            {
                Best = _chosen.ToDictionary(kv => kv.Key, kv => kv.Value.ToList());
                return true;
            }

            BuildOrder(pool);
            int cid = _order[0];
            int tid = TeacherOf(cid);

            var dom = Domain(cid, tid);
            if (dom.Count + _chosen[cid].Count < Need(cid)) return false;

            var rest = pool.Where(x => x != cid).ToList();
            dom.Sort((a, b) => ConflictScore(a, rest).CompareTo(ConflictScore(b, rest)));

            foreach (var sc in dom)
            {
                _chosen[cid].Add(sc);
                _used.Add(sc);
                _busyTeacher[tid].Add(sc);
                _busyTeacherDaySlot[tid].Add(DaySlotKey(sc.DayIdx, sc.SlotIdx)); // 🔧 mark (day,slot)

                bool done = _chosen[cid].Count == Need(cid);
                var nextPool = pool;
                if (done) nextPool = pool.Where(x => x != cid).ToList();

                if (ForwardOk(nextPool) && Dfs(nextPool)) return true;

                _chosen[cid].RemoveAt(_chosen[cid].Count - 1);
                _used.Remove(sc);
                _busyTeacher[tid].Remove(sc);
                _busyTeacherDaySlot[tid].Remove(DaySlotKey(sc.DayIdx, sc.SlotIdx)); // 🔧 unmark
            }
            return false;
        }
    }

    // ===== Helpers: dựng block từ “danh sách slot cho phép” theo DOW =====
    public static class BlockBuilder
    {
        // tạo GlobalBlock bằng cách khóa tất cả slot KHÔNG thuộc “allowedByDow”
        // allowedByDow: key = dow(0..6), value = danh sách slotIdx cho phép
        public static void ApplyGlobalBlocksFromAllowed(
            Problem pb, Config cfg, Dictionary<int, HashSet<int>> allowedByDow)
        {
            for (int d = 0; d < cfg.DaysTotal; d++)
            {
                int dow = (cfg.StartDow + d) % 7;
                var allowed = allowedByDow.TryGetValue(dow, out var set) ? set : new HashSet<int>();
                for (int s = 0; s < cfg.TimeSlots.Count; s++)
                {
                    bool ok = allowed.Contains(s);
                    if (!ok)
                    {
                        for (int r = 0; r < cfg.Rooms; r++)
                            pb.GlobalBlock.Add(SlotCode.Encode(d, s, r));
                    }
                }
            }
        }

        // tạo block cho giáo viên theo DOW + slot cho phép (nếu cần)
        public static void ApplyTeacherAllowed(
            Problem pb, Config cfg, int teacherId, Dictionary<int, HashSet<int>> allowedByDow)
        {
            if (!pb.TeacherBlock.ContainsKey(teacherId)) pb.TeacherBlock[teacherId] = new HashSet<SlotCode>();
            var blk = pb.TeacherBlock[teacherId];

            for (int d = 0; d < cfg.DaysTotal; d++)
            {
                int dow = (cfg.StartDow + d) % 7;
                var allowed = allowedByDow.TryGetValue(dow, out var set) ? set : new HashSet<int>();
                for (int s = 0; s < cfg.TimeSlots.Count; s++)
                {
                    bool ok = allowed.Contains(s);
                    if (!ok)
                    {
                        for (int r = 0; r < cfg.Rooms; r++)
                            blk.Add(SlotCode.Encode(d, s, r));
                    }
                }
            }
        }
    }

    // ===== Program (3 test cases) =====
    public static class Program
    {
        public static void Main()
        {
            Console.OutputEncoding = System.Text.Encoding.UTF8;

            // TimeSlots (khớp DB)
            var timeSlots = new List<TimeSlotDef>
            {
                new() { SlotId = 0, Label = "07-09", Start = new(7,0),  End = new(9,0)  },
                new() { SlotId = 1, Label = "09-11", Start = new(9,0),  End = new(11,0) },
                new() { SlotId = 2, Label = "13-15", Start = new(13,0), End = new(15,0) },
                new() { SlotId = 3, Label = "15-17", Start = new(15,0), End = new(17,0) },
                new() { SlotId = 4, Label = "17-19", Start = new(17,0), End = new(19,0) },
                new() { SlotId = 5, Label = "19-21", Start = new(19,0), End = new(21,0) },
            };

            // ======= TEST CASE 1 =======
            Console.WriteLine("=== TEST CASE 1: 1 room, 1 teacher, 8 classes, 1 week (MinGap=2) ===");
            var cfg1 = new Config
            {
                TimeSlots = timeSlots,
                Rooms = 1,
                DaysTotal = 7,
                StartDow = 0, // Monday
                MinGapDays = 2,
                StartDate = new DateOnly(2025, 10, 06)
            };

            var classes1 = new List<ClassInfo>();
            for (int i = 1; i <= 8; i++) classes1.Add(new ClassInfo { Id = i, SessionsPerWeek = 2, TeacherId = 1 });

            var pb1 = new Problem { Classes = classes1 };

            var allowedByDow1 = new Dictionary<int, HashSet<int>>
            {
                // Mon..Sat: only 17-19(4), 19-21(5)
                { 0, new HashSet<int>{4,5} }, { 1, new HashSet<int>{4,5} }, { 2, new HashSet<int>{4,5} },
                { 3, new HashSet<int>{4,5} }, { 4, new HashSet<int>{4,5} }, { 5, new HashSet<int>{4,5} },
                // Sun: 07-09(0), 09-11(1), 15-17(3), 17-19(4), 19-21(5)
                { 6, new HashSet<int>{0,1,3,4,5} }
            };
            BlockBuilder.ApplyGlobalBlocksFromAllowed(pb1, cfg1, allowedByDow1);
            var result1 = RunAndPrint("CASE 1", cfg1, pb1);
            Console.WriteLine();

            // ======= TEST CASE 2 =======
            Console.WriteLine("=== TEST CASE 2: 4 weeks, 4 rooms, 10 classes / 3 teachers (MinGap=2) ===");
            var cfg2 = new Config
            {
                TimeSlots = timeSlots,
                Rooms = 4,
                DaysTotal = 28, // 4 weeks
                StartDow = 0,
                MinGapDays = 2,
                StartDate = new DateOnly(2025, 10, 06)
            };

            var classes2 = new List<ClassInfo>();
            for (int i = 1; i <= 10; i++)
            {
                int teacher = (i % 3) + 1; // 1..3
                classes2.Add(new ClassInfo { Id = i, SessionsPerWeek = 3, TeacherId = teacher });
            }
            var pb2 = new Problem { Classes = classes2 };

            // Teacher 2 bận Wed(2) slot 1 mỗi tuần; Teacher 3 bận Fri(4) slot 0 mỗi tuần
            var teacher2Allowed = new Dictionary<int, HashSet<int>> { { 2, new HashSet<int> { 0, 2, 3, 4, 5 } } };
            var teacher3Allowed = new Dictionary<int, HashSet<int>> { { 4, new HashSet<int> { 1, 2, 3, 4, 5 } } };
            BlockBuilder.ApplyTeacherAllowed(pb2, cfg2, 2, teacher2Allowed);
            BlockBuilder.ApplyTeacherAllowed(pb2, cfg2, 3, teacher3Allowed);

            var result2 = RunAndPrint("CASE 2", cfg2, pb2);
            Console.WriteLine();

            // ======= TEST CASE 3 =======
            Console.WriteLine("=== TEST CASE 3: 1 room, 3 teachers, 6 classes, custom blocks (MinGap=2) ===");
            var cfg3 = new Config
            {
                TimeSlots = timeSlots,
                Rooms = 1,
                DaysTotal = 14, // 2 weeks
                StartDow = 1,   // Tuesday
                MinGapDays = 2,
                StartDate = new DateOnly(2025, 10, 07)
            };
            var classes3 = new List<ClassInfo>
            {
                new() { Id = 1, SessionsPerWeek = 2, TeacherId = 10 },
                new() { Id = 2, SessionsPerWeek = 2, TeacherId = 10 },
                new() { Id = 3, SessionsPerWeek = 2, TeacherId = 11 },
                new() { Id = 4, SessionsPerWeek = 2, TeacherId = 11 },
                new() { Id = 5, SessionsPerWeek = 2, TeacherId = 12 },
                new() { Id = 6, SessionsPerWeek = 2, TeacherId = 12 },
            };
            var pb3 = new Problem { Classes = classes3 };

            // Global: khóa slot 0 và 1 mọi ngày (chỉ học từ chiều tối)
            for (int d = 0; d < cfg3.DaysTotal; d++)
                for (int r = 0; r < cfg3.Rooms; r++)
                {
                    pb3.GlobalBlock.Add(SlotCode.Encode(d, 0, r));
                    pb3.GlobalBlock.Add(SlotCode.Encode(d, 1, r));
                }

            // Class 1 bị block slot 4 toàn bộ (không học 17-19)
            pb3.ClassBlock[1] = new HashSet<SlotCode>();
            for (int d = 0; d < cfg3.DaysTotal; d++)
                pb3.ClassBlock[1].Add(SlotCode.Encode(d, 4, 0));

            // Teacher 12 không dạy Chủ nhật (dow=6) mọi slot
            pb3.TeacherBlock[12] = new HashSet<SlotCode>();
            for (int d = 0; d < cfg3.DaysTotal; d++)
            {
                int dow = (cfg3.StartDow + d) % 7;
                if (dow == 6)
                    for (int s = 0; s < cfg3.TimeSlots.Count; s++)
                        pb3.TeacherBlock[12].Add(SlotCode.Encode(d, s, 0));
            }

            var result3 = RunAndPrint("CASE 3", cfg3, pb3);
            Console.WriteLine();

            Console.WriteLine("SUMMARY:");
            Console.WriteLine($"Case1: {(result1 ? "OK" : "FAIL")}");
            Console.WriteLine($"Case2: {(result2 ? "OK" : "FAIL")}");
            Console.WriteLine($"Case3: {(result3 ? "OK" : "FAIL")}");
        }

        private static bool RunAndPrint(string title, Config cfg, Problem pb)
        {
            var sch = new Scheduler(cfg, pb);
            var ok = sch.Solve();

            if (!ok)
            {
                Console.WriteLine($"[{title}] Không lập được lịch.");
                return false;
            }

            // Giả lập RoomId/RoomName từ room index
            Guid RoomGuidOf(int roomIdx) => GuidUtility.Create(GuidUtility.UrlNamespace, $"room-{roomIdx + 1}");
            string RoomNameOf(int roomIdx) => $"Room {roomIdx + 1}";

            // Chuyển Best -> ScheduleRows (khớp DB ClassSchedules)
            var rows = new List<ScheduleRow>();
            foreach (var (cid, slots) in sch.Best.OrderBy(k => k.Key))
            {
                foreach (var sc in slots.OrderBy(s => s.DayIdx).ThenBy(s => s.SlotIdx))
                {
                    var ts = cfg.TimeSlots[sc.SlotIdx];
                    rows.Add(new ScheduleRow
                    {
                        ClassId = cid,
                        SessionDate = cfg.StartDate.AddDays(sc.DayIdx),
                        SlotId = ts.SlotId,
                        RoomId = RoomGuidOf(sc.Room),
                        IsAutoGenerated = true,
                        StartTime = ts.Start,
                        EndTime = ts.End,
                        RoomName = RoomNameOf(sc.Room)
                    });
                }
            }

            Console.WriteLine($"[{title}] Lập lịch thành công. Tổng buổi: {rows.Count}");
            foreach (var g in rows.GroupBy(r => r.ClassId).OrderBy(g => g.Key))
            {
                Console.WriteLine($"  Lớp {g.Key}:");
                foreach (var r in g)
                    Console.WriteLine($"    • {r.SessionDate:yyyy-MM-dd}  Slot#{r.SlotId} ({r.StartTime}-{r.EndTime})  {r.RoomName}");
            }
            return true;
        }
    }

    // ===== Deterministic Guid for demo (so output roomId stable) =====
    // RFC 4122 name-based UUID v5 simplified
    public static class GuidUtility
    {
        public static readonly Guid UrlNamespace = new("6ba7b811-9dad-11d1-80b4-00c04fd430c8");

        public static Guid Create(Guid namespaceId, string name)
        {
            var ns = namespaceId.ToByteArray();
            SwapByteOrder(ns);
            var nameBytes = System.Text.Encoding.UTF8.GetBytes(name);
            var data = new byte[ns.Length + nameBytes.Length];
            Buffer.BlockCopy(ns, 0, data, 0, ns.Length);
            Buffer.BlockCopy(nameBytes, 0, data, ns.Length, nameBytes.Length);
            var sha1 = System.Security.Cryptography.SHA1.HashData(data);
            var newGuid = new byte[16];
            Array.Copy(sha1, 0, newGuid, 0, 16);
            newGuid[6] = (byte)((newGuid[6] & 0x0F) | (5 << 4));  // version 5
            newGuid[8] = (byte)((newGuid[8] & 0x3F) | 0x80);      // variant
            SwapByteOrder(newGuid);
            return new Guid(newGuid);
        }

        private static void SwapByteOrder(byte[] guid)
        {
            void Swap(int a, int b) { (guid[a], guid[b]) = (guid[b], guid[a]); }
            Swap(0, 3); Swap(1, 2);
            Swap(4, 5); Swap(6, 7);
        }
    }
}

*/


using System;
using System.Collections.Generic;
using System.Linq;

namespace Backtracking
{
    // ===== Config (khớp DB Hybrid: TimeSlots / Rooms / MinGapDays / StartDate) =====
    public sealed class TimeSlotDef
    {
        public byte SlotId { get; init; }
        public string Label { get; init; } = "";
        public TimeOnly Start { get; init; }
        public TimeOnly End { get; init; }
    }

    public sealed class Config
    {
        public required List<TimeSlotDef> TimeSlots { get; init; }   // index = SlotId
        public required int Rooms { get; init; }                      // 1..63
        public required int DaysTotal { get; init; }                  // EndDate - StartDate + 1
        public required int StartDow { get; init; }                   // 0=Mon..6=Sun
        public required int MinGapDays { get; init; }                 // ≥2
        public required DateOnly StartDate { get; init; }             // để in SessionDate
    }

    // ===== Input bài toán (khớp với DB Hybrid) =====
    public sealed class ClassInfo
    {
        public int Id { get; init; }                 // Classes.ClassId (minh hoạ: int)
        public int SessionsPerWeek { get; init; }    // 1|2|3|...
        public int TeacherId { get; init; }          // Users.UserId (minh hoạ: int)
    }

    // Slot encode 32-bit: [dayIdx<<9 | slot<<6 | room]  (day<=~8M, slot<=7, room<=63)
    public readonly struct SlotCode : IEquatable<SlotCode>
    {
        public readonly uint Code;
        public SlotCode(uint code) => Code = code;
        public static SlotCode Encode(int dayIdx, int slot, int room)
            => new((uint)((dayIdx << 9) | (slot << 6) | room));
        public int DayIdx => (int)(Code >> 9);
        public int SlotIdx => (int)((Code >> 6) & 0x7);
        public int Room => (int)(Code & 0x3F);
        public bool Equals(SlotCode other) => Code == other.Code;
        public override bool Equals(object? obj) => obj is SlotCode sc && Equals(sc);
        public override int GetHashCode() => (int)Code;
        public override string ToString() => $"[d:{DayIdx} s:{SlotIdx} r:{Room}]";
    }

    public sealed class Problem
    {
        public required List<ClassInfo> Classes { get; init; }
        public HashSet<SlotCode> GlobalBlock { get; } = new();
        public Dictionary<int, HashSet<SlotCode>> ClassBlock { get; } = new();   // ClassId -> blocked SlotCode
        public Dictionary<int, HashSet<SlotCode>> TeacherBlock { get; } = new(); // TeacherId -> blocked SlotCode (room-specific)
    }

    // ===== Output map về DB ClassSchedules =====
    public sealed class ScheduleRow
    {
        public int ClassId { get; init; }
        public DateOnly SessionDate { get; init; } // = StartDate + dayIdx
        public byte SlotId { get; init; }          // FK TimeSlots
        public Guid RoomId { get; init; }          // minh hoạ: map từ room index -> Guid
        public bool IsAutoGenerated { get; init; } = true;
        public TimeOnly StartTime { get; init; }   // từ TimeSlots
        public TimeOnly EndTime { get; init; }     // từ TimeSlots
        public string RoomName { get; init; } = ""; // nếu cần fill
    }

    // ===== Solver (MRV + LCV + Forward-Checking) =====
    public sealed class Scheduler
    {
        private readonly Config _cfg;
        private readonly Problem _pb;

        private readonly Dictionary<int, List<SlotCode>> _chosen = new();
        private readonly HashSet<SlotCode> _used = new();

        // Giáo viên bận theo slot *cụ thể* (có room) – giữ lại cho an toàn
        private readonly Dictionary<int, HashSet<SlotCode>> _busyTeacher = new(); // teacher -> using slots (room-specific)

        // FIX: Giáo viên bận theo (day,slot) bất kể phòng
        private readonly Dictionary<int, HashSet<int>> _busyTeacherDaySlot = new(); // teacher -> (day<<8)|slot
        private static int DaySlotKey(int dayIdx, int slotIdx) => (dayIdx << 8) | slotIdx;

        private List<int> _order = new(); // class order (MRV)

        public Dictionary<int, List<SlotCode>> Best { get; private set; } = new();

        public Scheduler(Config cfg, Problem pb)
        {
            _cfg = cfg;
            _pb = pb;

            foreach (var c in pb.Classes)
            {
                _chosen[c.Id] = new List<SlotCode>();
                _busyTeacher.TryAdd(c.TeacherId, new HashSet<SlotCode>());
                _busyTeacherDaySlot.TryAdd(c.TeacherId, new HashSet<int>()); // init
                _pb.ClassBlock.TryAdd(c.Id, new HashSet<SlotCode>());
                _pb.TeacherBlock.TryAdd(c.TeacherId, new HashSet<SlotCode>());
            }
        }

        public bool Solve()
        {
            var pool = _pb.Classes.Select(c => c.Id).ToList();
            return Dfs(pool);
        }

        private bool GapOk(int d1, int d2) => Math.Abs(d2 - d1) >= _cfg.MinGapDays;

        private bool ClassGapOk(List<SlotCode> cur, int day)
        {
            for (int i = 0; i < cur.Count; i++)
                if (!GapOk(cur[i].DayIdx, day)) return false;
            return true;
        }

        private int Need(int cid) => _pb.Classes.First(c => c.Id == cid).SessionsPerWeek;

        private int TeacherOf(int cid) => _pb.Classes.First(c => c.Id == cid).TeacherId;

        private List<SlotCode> Domain(int cid, int teacher)
        {
            var dom = new List<SlotCode>();
            var blkClass = _pb.ClassBlock[cid];

            for (int d = 0; d < _cfg.DaysTotal; d++)
            {
                if (!ClassGapOk(_chosen[cid], d)) continue;

                for (int s = 0; s < _cfg.TimeSlots.Count; s++)
                {
                    // chặn giáo viên trùng (ngày,slot) bất kể phòng
                    int dsKey = DaySlotKey(d, s);
                    if (_busyTeacherDaySlot[teacher].Contains(dsKey)) continue;

                    for (int r = 0; r < _cfg.Rooms; r++)
                    {
                        var sc = SlotCode.Encode(d, s, r);
                        if (_pb.GlobalBlock.Contains(sc)) continue;
                        if (blkClass.Contains(sc)) continue;
                        if (_pb.TeacherBlock[teacher].Contains(sc)) continue; // teacher rule (room-level blocks)
                        if (_busyTeacher[teacher].Contains(sc)) continue;     // keep
                        if (_used.Contains(sc)) continue;
                        dom.Add(sc);
                    }
                }
            }
            return dom;
        }

        private int ConflictScore(SlotCode sc, IReadOnlyList<int> remaining)
        {
            int cnt = 0;
            foreach (var cid in remaining)
            {
                var t = TeacherOf(cid);
                if (_pb.ClassBlock[cid].Contains(sc)) continue;
                if (_busyTeacher[t].Contains(sc)) continue;
                if (_pb.TeacherBlock[t].Contains(sc)) continue;
                cnt++;
            }
            return cnt;
        }

        private bool ForwardOk(IReadOnlyList<int> rem)
        {
            foreach (var cid in rem)
            {
                var t = TeacherOf(cid);
                var dom = Domain(cid, t);
                if (dom.Count + _chosen[cid].Count < Need(cid)) return false;
            }
            return true;
        }

        private void BuildOrder(List<int> pool)
        {
            _order = pool.Select(cid =>
            {
                var t = TeacherOf(cid);
                var dsz = Domain(cid, t).Count;
                return (cid, dsz);
            })
            .OrderBy(p => p.dsz)
            .Select(p => p.cid)
            .ToList();
        }

        private bool Dfs(List<int> pool)
        {
            if (pool.Count == 0)
            {
                Best = _chosen.ToDictionary(kv => kv.Key, kv => kv.Value.ToList());
                return true;
            }

            BuildOrder(pool);
            int cid = _order[0];
            int tid = TeacherOf(cid);

            var dom = Domain(cid, tid);
            if (dom.Count + _chosen[cid].Count < Need(cid)) return false;

            var rest = pool.Where(x => x != cid).ToList();
            dom.Sort((a, b) => ConflictScore(a, rest).CompareTo(ConflictScore(b, rest)));

            foreach (var sc in dom)
            {
                _chosen[cid].Add(sc);
                _used.Add(sc);
                _busyTeacher[tid].Add(sc);
                _busyTeacherDaySlot[tid].Add(DaySlotKey(sc.DayIdx, sc.SlotIdx)); // mark (day,slot)

                bool done = _chosen[cid].Count == Need(cid);
                var nextPool = pool;
                if (done) nextPool = pool.Where(x => x != cid).ToList();

                if (ForwardOk(nextPool) && Dfs(nextPool)) return true;

                _chosen[cid].RemoveAt(_chosen[cid].Count - 1);
                _used.Remove(sc);
                _busyTeacher[tid].Remove(sc);
                _busyTeacherDaySlot[tid].Remove(DaySlotKey(sc.DayIdx, sc.SlotIdx)); // unmark
            }
            return false;
        }
    }

    // ===== Helpers: dựng block từ “danh sách slot cho phép” theo DOW =====
    public static class BlockBuilder
    {
        // tạo GlobalBlock bằng cách khóa tất cả slot KHÔNG thuộc “allowedByDow”
        // allowedByDow: key = dow(0..6), value = danh sách slotIdx cho phép
        public static void ApplyGlobalBlocksFromAllowed(
            Problem pb, Config cfg, Dictionary<int, HashSet<int>> allowedByDow)
        {
            for (int d = 0; d < cfg.DaysTotal; d++)
            {
                int dow = (cfg.StartDow + d) % 7;
                var allowed = allowedByDow.TryGetValue(dow, out var set) ? set : new HashSet<int>();
                for (int s = 0; s < cfg.TimeSlots.Count; s++)
                {
                    bool ok = allowed.Contains(s);
                    if (!ok)
                    {
                        for (int r = 0; r < cfg.Rooms; r++)
                            pb.GlobalBlock.Add(SlotCode.Encode(d, s, r));
                    }
                }
            }
        }

        // tạo block cho giáo viên theo DOW + slot cho phép (nếu cần)
        public static void ApplyTeacherAllowed(
            Problem pb, Config cfg, int teacherId, Dictionary<int, HashSet<int>> allowedByDow)
        {
            if (!pb.TeacherBlock.ContainsKey(teacherId)) pb.TeacherBlock[teacherId] = new HashSet<SlotCode>();
            var blk = pb.TeacherBlock[teacherId];

            for (int d = 0; d < cfg.DaysTotal; d++)
            {
                int dow = (cfg.StartDow + d) % 7;
                var allowed = allowedByDow.TryGetValue(dow, out var set) ? set : new HashSet<int>();
                for (int s = 0; s < cfg.TimeSlots.Count; s++)
                {
                    bool ok = allowed.Contains(s);
                    if (!ok)
                    {
                        for (int r = 0; r < cfg.Rooms; r++)
                            blk.Add(SlotCode.Encode(d, s, r));
                    }
                }
            }
        }
    }

    public static class Program
    {
        public static void Main()
        {
            Console.OutputEncoding = System.Text.Encoding.UTF8;

            // TimeSlots (khớp DB)
            var timeSlots = new List<TimeSlotDef>
            {
                new() { SlotId = 0, Label = "07-09", Start = new(7,0),  End = new(9,0)  },
                new() { SlotId = 1, Label = "09-11", Start = new(9,0),  End = new(11,0) },
                new() { SlotId = 2, Label = "13-15", Start = new(13,0), End = new(15,0) },
                new() { SlotId = 3, Label = "15-17", Start = new(15,0), End = new(17,0) },
                new() { SlotId = 4, Label = "17-19", Start = new(17,0), End = new(19,0) },
                new() { SlotId = 5, Label = "19-21", Start = new(19,0), End = new(21,0) },
            };

            // ======= TEST CASE 1 =======
            Console.WriteLine("=== TEST CASE 1: 1 room, 1 teacher, 8 classes, 1 week (MinGap=2) ===");
            var cfg1 = new Config
            {
                TimeSlots = timeSlots,
                Rooms = 1,
                DaysTotal = 7,
                StartDow = 0, // Monday
                MinGapDays = 2,
                StartDate = new DateOnly(2025, 10, 06)
            };

            var classes1 = new List<ClassInfo>();
            for (int i = 1; i <= 8; i++) classes1.Add(new ClassInfo { Id = i, SessionsPerWeek = 2, TeacherId = 1 });

            var pb1 = new Problem { Classes = classes1 };

            var allowedByDow1 = new Dictionary<int, HashSet<int>>
            {
                { 0, new HashSet<int>{4,5} }, { 1, new HashSet<int>{4,5} }, { 2, new HashSet<int>{4,5} },
                { 3, new HashSet<int>{4,5} }, { 4, new HashSet<int>{4,5} }, { 5, new HashSet<int>{4,5} },
                { 6, new HashSet<int>{0,1,3,4,5} }
            };
            BlockBuilder.ApplyGlobalBlocksFromAllowed(pb1, cfg1, allowedByDow1);
            var result1 = RunAndPrint("CASE 1", cfg1, pb1);
            Console.WriteLine();

            // ======= TEST CASE 2 =======
            Console.WriteLine("=== TEST CASE 2: 4 weeks, 4 rooms, 10 classes / 3 teachers (MinGap=2) ===");
            var cfg2 = new Config
            {
                TimeSlots = timeSlots,
                Rooms = 4,
                DaysTotal = 28, // 4 weeks
                StartDow = 0,
                MinGapDays = 2,
                StartDate = new DateOnly(2025, 10, 06)
            };

            var classes2 = new List<ClassInfo>();
            for (int i = 1; i <= 10; i++)
            {
                int teacher = (i % 3) + 1; // 1..3
                classes2.Add(new ClassInfo { Id = i, SessionsPerWeek = 3, TeacherId = teacher });
            }
            var pb2 = new Problem { Classes = classes2 };

            var teacher2Allowed = new Dictionary<int, HashSet<int>> { { 2, new HashSet<int> { 0, 2, 3, 4, 5 } } };
            var teacher3Allowed = new Dictionary<int, HashSet<int>> { { 4, new HashSet<int> { 1, 2, 3, 4, 5 } } };
            BlockBuilder.ApplyTeacherAllowed(pb2, cfg2, 2, teacher2Allowed);
            BlockBuilder.ApplyTeacherAllowed(pb2, cfg2, 3, teacher3Allowed);

            var result2 = RunAndPrint("CASE 2", cfg2, pb2);
            Console.WriteLine();

            // ======= TEST CASE 3 =======
            Console.WriteLine("=== TEST CASE 3: 1 room, 3 teachers, 6 classes, custom blocks (MinGap=2) ===");
            var cfg3 = new Config
            {
                TimeSlots = timeSlots,
                Rooms = 1,
                DaysTotal = 14, // 2 weeks
                StartDow = 1,   // Tuesday
                MinGapDays = 2,
                StartDate = new DateOnly(2025, 10, 07)
            };
            var classes3 = new List<ClassInfo>
            {
                new() { Id = 1, SessionsPerWeek = 2, TeacherId = 10 },
                new() { Id = 2, SessionsPerWeek = 2, TeacherId = 10 },
                new() { Id = 3, SessionsPerWeek = 2, TeacherId = 11 },
                new() { Id = 4, SessionsPerWeek = 2, TeacherId = 11 },
                new() { Id = 5, SessionsPerWeek = 2, TeacherId = 12 },
                new() { Id = 6, SessionsPerWeek = 2, TeacherId = 12 },
            };
            var pb3 = new Problem { Classes = classes3 };

            for (int d = 0; d < cfg3.DaysTotal; d++)
                for (int r = 0; r < cfg3.Rooms; r++)
                {
                    pb3.GlobalBlock.Add(SlotCode.Encode(d, 0, r));
                    pb3.GlobalBlock.Add(SlotCode.Encode(d, 1, r));
                }
            pb3.ClassBlock[1] = new HashSet<SlotCode>();
            for (int d = 0; d < cfg3.DaysTotal; d++)
                pb3.ClassBlock[1].Add(SlotCode.Encode(d, 4, 0));

            pb3.TeacherBlock[12] = new HashSet<SlotCode>();
            for (int d = 0; d < cfg3.DaysTotal; d++)
            {
                int dow = (cfg3.StartDow + d) % 7;
                if (dow == 6)
                    for (int s = 0; s < cfg3.TimeSlots.Count; s++)
                        pb3.TeacherBlock[12].Add(SlotCode.Encode(d, s, 0));
            }

            var result3 = RunAndPrint("CASE 3", cfg3, pb3);
            Console.WriteLine();

            // ======= TEST CASE 4 (bình thường) =======
            Console.WriteLine("=== TEST CASE 4: Normal – 2 weeks, 2 rooms, 5 classes / 2 teachers ===");
            var cfg4 = new Config
            {
                TimeSlots = timeSlots,
                Rooms = 2,
                DaysTotal = 14,
                StartDow = 2, // Wednesday
                MinGapDays = 2,
                StartDate = new DateOnly(2025, 10, 08)
            };
            var classes4 = new List<ClassInfo>
            {
                new() { Id = 101, SessionsPerWeek = 2, TeacherId = 201 },
                new() { Id = 102, SessionsPerWeek = 2, TeacherId = 201 },
                new() { Id = 103, SessionsPerWeek = 2, TeacherId = 202 },
                new() { Id = 104, SessionsPerWeek = 2, TeacherId = 202 },
                new() { Id = 105, SessionsPerWeek = 2, TeacherId = 202 },
            };
            var pb4 = new Problem { Classes = classes4 };
            var result4 = RunAndPrint("CASE 4", cfg4, pb4);
            Console.WriteLine();

            // ======= TEST CASE 5 (đặc biệt: chỉ học cuối tuần) =======
            Console.WriteLine("=== TEST CASE 5: Weekend-only, 2 weeks, 1 room, 3 classes (MinGap=2) ===");
            var cfg5 = new Config
            {
                TimeSlots = timeSlots,
                Rooms = 1,
                DaysTotal = 14,
                StartDow = 0, // Monday
                MinGapDays = 2,
                StartDate = new DateOnly(2025, 10, 06)
            };
            var classes5 = new List<ClassInfo>
            {
                new() { Id = 201, SessionsPerWeek = 2, TeacherId = 301 },
                new() { Id = 202, SessionsPerWeek = 2, TeacherId = 301 },
                new() { Id = 203, SessionsPerWeek = 2, TeacherId = 301 },
            };
            var pb5 = new Problem { Classes = classes5 };
            var weekendAllowed = new Dictionary<int, HashSet<int>>
            {
                { 5, new HashSet<int>{4,5} }, // Saturday
                { 6, new HashSet<int>{4,5} }  // Sunday
            };
            BlockBuilder.ApplyGlobalBlocksFromAllowed(pb5, cfg5, weekendAllowed);
            var result5 = RunAndPrint("CASE 5", cfg5, pb5);
            Console.WriteLine();

            // ======= TEST CASE 6 (đặc biệt: holiday toàn trung tâm) =======
            Console.WriteLine("=== TEST CASE 6: Global holidays block two days (2 weeks, 3 rooms) ===");
            var cfg6 = new Config
            {
                TimeSlots = timeSlots,
                Rooms = 3,
                DaysTotal = 14,
                StartDow = 0,
                MinGapDays = 2,
                StartDate = new DateOnly(2025, 10, 06)
            };
            var classes6 = new List<ClassInfo>();
            for (int i = 301; i <= 306; i++)
            {
                int teacher = 400 + ((i - 301) % 3); // 400..402
                classes6.Add(new ClassInfo { Id = i, SessionsPerWeek = 2, TeacherId = teacher });
            }
            var pb6 = new Problem { Classes = classes6 };
            // Holiday dayIdx 3 & 10: block all slots/rooms
            foreach (var d in new[] { 3, 10 })
                for (int s = 0; s < cfg6.TimeSlots.Count; s++)
                    for (int r = 0; r < cfg6.Rooms; r++)
                        pb6.GlobalBlock.Add(SlotCode.Encode(d, s, r));
            var result6 = RunAndPrint("CASE 6", cfg6, pb6);
            Console.WriteLine();

            // ======= TEST CASE 7 (đặc biệt: GV #1 chỉ rảnh Monday slot0, lớp cần 3 buổi) =======
            Console.WriteLine("=== TEST CASE 7: Teacher#1 only Monday slot#0, 3 weeks, 2 rooms ===");
            var cfg7 = new Config
            {
                TimeSlots = timeSlots,
                Rooms = 2,
                DaysTotal = 21, // 3 weeks
                StartDow = 0,   // Monday
                MinGapDays = 2,
                StartDate = new DateOnly(2025, 10, 06)
            };
            var classes7 = new List<ClassInfo>
            {
                new() { Id = 401, SessionsPerWeek = 3, TeacherId = 1 }, // phải chạy 3 thứ Hai
                new() { Id = 402, SessionsPerWeek = 2, TeacherId = 2 },
                new() { Id = 403, SessionsPerWeek = 2, TeacherId = 3 },
                new() { Id = 404, SessionsPerWeek = 2, TeacherId = 3 },
            };
            var pb7 = new Problem { Classes = classes7 };
            // Teacher #1 chỉ allowed Monday slot#0
            var t1Allowed = new Dictionary<int, HashSet<int>> { { 0, new HashSet<int> { 0 } } };
            BlockBuilder.ApplyTeacherAllowed(pb7, cfg7, 1, t1Allowed);
            var result7 = RunAndPrint("CASE 7", cfg7, pb7);
            Console.WriteLine();

            // ======= TEST CASE 8 (KHÔNG xếp được) =======
            Console.WriteLine("=== TEST CASE 8: UNSCHEDULABLE – 1 week, 1 room, 5 classes but only Mon slot#0 allowed ===");
            var cfg8 = new Config
            {
                TimeSlots = timeSlots,
                Rooms = 1,
                DaysTotal = 7,
                StartDow = 0,
                MinGapDays = 1,
                StartDate = new DateOnly(2025, 10, 06)
            };
            var classes8 = new List<ClassInfo>
            {
                new() { Id = 501, SessionsPerWeek = 1, TeacherId = 1 },
                new() { Id = 502, SessionsPerWeek = 1, TeacherId = 1 },
                new() { Id = 503, SessionsPerWeek = 1, TeacherId = 1 },
                new() { Id = 504, SessionsPerWeek = 1, TeacherId = 1 },
                new() { Id = 505, SessionsPerWeek = 1, TeacherId = 1 },
            };
            var pb8 = new Problem { Classes = classes8 };
            var onlyMonSlot0 = new Dictionary<int, HashSet<int>> { { 0, new HashSet<int> { 0 } } };
            BlockBuilder.ApplyGlobalBlocksFromAllowed(pb8, cfg8, onlyMonSlot0);
            var result8 = RunAndPrint("CASE 8", cfg8, pb8); // dự kiến FAIL
            Console.WriteLine();

            // In tóm tắt pass/fail tám case
            Console.WriteLine("SUMMARY:");
            Console.WriteLine($"Case1: {(result1 ? "OK" : "FAIL")}");
            Console.WriteLine($"Case2: {(result2 ? "OK" : "FAIL")}");
            Console.WriteLine($"Case3: {(result3 ? "OK" : "FAIL")}");
            Console.WriteLine($"Case4: {(result4 ? "OK" : "FAIL")}");
            Console.WriteLine($"Case5: {(result5 ? "OK" : "FAIL")}");
            Console.WriteLine($"Case6: {(result6 ? "OK" : "FAIL")}");
            Console.WriteLine($"Case7: {(result7 ? "OK" : "FAIL")}");
            Console.WriteLine($"Case8: {(result8 ? "OK" : "FAIL (expected)")}"); // expected fail
        }

        private static bool RunAndPrint(string title, Config cfg, Problem pb)
        {
            var sch = new Scheduler(cfg, pb);
            var ok = sch.Solve();

            if (!ok)
            {
                Console.WriteLine($"[{title}] Không lập được lịch.");
                return false;
            }

            // Giả lập RoomId/RoomName từ room index
            Guid RoomGuidOf(int roomIdx) => GuidUtility.Create(GuidUtility.UrlNamespace, $"room-{roomIdx + 1}");
            string RoomNameOf(int roomIdx) => $"Room {roomIdx + 1}";

            // Chuyển Best -> ScheduleRows (khớp DB ClassSchedules)
            var rows = new List<ScheduleRow>();
            foreach (var (cid, slots) in sch.Best.OrderBy(k => k.Key))
            {
                foreach (var sc in slots.OrderBy(s => s.DayIdx).ThenBy(s => s.SlotIdx))
                {
                    var ts = cfg.TimeSlots[sc.SlotIdx];
                    rows.Add(new ScheduleRow
                    {
                        ClassId = cid,
                        SessionDate = cfg.StartDate.AddDays(sc.DayIdx),
                        SlotId = ts.SlotId,
                        RoomId = RoomGuidOf(sc.Room),
                        IsAutoGenerated = true,
                        StartTime = ts.Start,
                        EndTime = ts.End,
                        RoomName = RoomNameOf(sc.Room)
                    });
                }
            }

            Console.WriteLine($"[{title}] Lập lịch thành công. Tổng buổi: {rows.Count}");
            foreach (var g in rows.GroupBy(r => r.ClassId).OrderBy(g => g.Key))
            {
                Console.WriteLine($"  Lớp {g.Key}:");
                foreach (var r in g)
                    Console.WriteLine($"    • {r.SessionDate:yyyy-MM-dd}  Slot#{r.SlotId} ({r.StartTime}-{r.EndTime})  {r.RoomName}");
            }
            return true;
        }
    }

    // ===== Deterministic Guid for demo (so output roomId stable) =====
    // RFC 4122 name-based UUID v5 simplified
    public static class GuidUtility
    {
        public static readonly Guid UrlNamespace = new("6ba7b811-9dad-11d1-80b4-00c04fd430c8");

        public static Guid Create(Guid namespaceId, string name)
        {
            var ns = namespaceId.ToByteArray();
            SwapByteOrder(ns);
            var nameBytes = System.Text.Encoding.UTF8.GetBytes(name);
            var data = new byte[ns.Length + nameBytes.Length];
            Buffer.BlockCopy(ns, 0, data, 0, ns.Length);
            Buffer.BlockCopy(nameBytes, 0, data, ns.Length, nameBytes.Length);
            var sha1 = System.Security.Cryptography.SHA1.HashData(data);
            var newGuid = new byte[16];
            Array.Copy(sha1, 0, newGuid, 0, 16);
            newGuid[6] = (byte)((newGuid[6] & 0x0F) | (5 << 4));  // version 5
            newGuid[8] = (byte)((newGuid[8] & 0x3F) | 0x80);      // variant
            SwapByteOrder(newGuid);
            return new Guid(newGuid);
        }

        private static void SwapByteOrder(byte[] guid)
        {
            void Swap(int a, int b) { (guid[a], guid[b]) = (guid[b], guid[a]); }
            Swap(0, 3); Swap(1, 2);
            Swap(4, 5); Swap(6, 7);
        }
    }
}
