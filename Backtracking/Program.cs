using System;
using System.Collections.Generic;
using System.Linq;

namespace Backtracking
{
    // ===== Config (khớp DB: TimeSlots, Rooms, StartDate/EndDate, MinGapDays) =====
    public sealed class TimeSlotDef
    {
        public byte SlotId { get; init; }
        public string Label { get; init; } = "";
        public TimeOnly Start { get; init; }
        public TimeOnly End { get; init; }
    }

    public sealed class Config
    {
        public required List<TimeSlotDef> TimeSlots { get; init; }   // index = SlotId
        public required int Rooms { get; init; }                      // 1..63 (mặc định)
        public required int DaysTotal { get; init; }                  // EndDate - StartDate + 1
        public required int StartDow { get; init; }                   // 0=Mon..6=Sun
        public required int MinGapDays { get; init; }                 // ≥2 mặc định
        public required DateOnly StartDate { get; init; }             // dùng để in SessionDate
    }

    // ===== Input bài toán (khớp với DB Hybrid) =====
    public sealed class ClassInfo
    {
        public int Id { get; init; }          // Classes.ClassId (minh hoạ: int)
        public int SessionsPerWeek { get; init; }  // 2|3|...
        public int TeacherId { get; init; }   // Users.UserId (minh hoạ: int)
    }

    // Slot encode 32-bit: [dayIdx<<9 | slot<<6 | room]  (day<=~8M, slot<=7, room<=63)
    public readonly struct SlotCode : IEquatable<SlotCode>
    {
        public readonly uint Code;
        public SlotCode(uint code) => Code = code;
        public static SlotCode Encode(int dayIdx, int slot, int room)
            => new((uint)((dayIdx << 9) | (slot << 6) | room));
        public int DayIdx => (int)(Code >> 9);
        public int SlotIdx => (int)((Code >> 6) & 0x7);
        public int Room => (int)(Code & 0x3F);
        public bool Equals(SlotCode other) => Code == other.Code;
        public override bool Equals(object? obj) => obj is SlotCode sc && Equals(sc);
        public override int GetHashCode() => (int)Code;
        public override string ToString() => $"[d:{DayIdx} s:{SlotIdx} r:{Room}]";
    }

    public sealed class Problem
    {
        public required List<ClassInfo> Classes { get; init; }
        public HashSet<SlotCode> GlobalBlock { get; } = new();
        public Dictionary<int, HashSet<SlotCode>> ClassBlock { get; } = new();   // ClassId -> blocked SlotCode
        public Dictionary<int, HashSet<SlotCode>> TeacherBlock { get; } = new(); // TeacherId -> blocked SlotCode
    }

    // ===== Output map về DB ClassSchedules =====
    public sealed class ScheduleRow
    {
        public int ClassId { get; init; }
        public DateOnly SessionDate { get; init; } // = StartDate + dayIdx
        public byte SlotId { get; init; }          // FK TimeSlots
        public Guid RoomId { get; init; }          // minh hoạ: map từ room index -> Guid
        public bool IsAutoGenerated { get; init; } = true;
        public TimeOnly StartTime { get; init; }   // từ TimeSlots
        public TimeOnly EndTime { get; init; }     // từ TimeSlots
        public string RoomName { get; init; } = ""; // nếu cần fill
    }

    // ===== Solver (MRV + LCV + Forward-Checking) =====
    public sealed class Scheduler
    {
        private readonly Config _cfg;
        private readonly Problem _pb;

        private readonly Dictionary<int, List<SlotCode>> _chosen = new();
        private readonly HashSet<SlotCode> _used = new();
        private readonly Dictionary<int, HashSet<SlotCode>> _busyTeacher = new(); // TeacherId -> using slots
        private List<int> _order = new();                                          // class order (MRV)

        public Dictionary<int, List<SlotCode>> Best { get; private set; } = new();

        public Scheduler(Config cfg, Problem pb)
        {
            _cfg = cfg;
            _pb = pb;

            foreach (var c in pb.Classes)
            {
                _chosen[c.Id] = new List<SlotCode>();
                _busyTeacher.TryAdd(c.TeacherId, new HashSet<SlotCode>());
                _pb.ClassBlock.TryAdd(c.Id, new HashSet<SlotCode>());
                _pb.TeacherBlock.TryAdd(c.TeacherId, new HashSet<SlotCode>());
            }
        }

        public bool Solve()
        {
            var pool = _pb.Classes.Select(c => c.Id).ToList();
            return Dfs(pool);
        }

        private static int DowAdd(int startDow, int dayIdx) => (startDow + dayIdx) % 7; // 0..6

        private bool GapOk(int d1, int d2) => Math.Abs(d2 - d1) >= _cfg.MinGapDays;

        private bool ClassGapOk(List<SlotCode> cur, int day)
        {
            for (int i = 0; i < cur.Count; i++)
                if (!GapOk(cur[i].DayIdx, day)) return false;
            return true;
        }

        private int Need(int cid) => _pb.Classes.First(c => c.Id == cid).SessionsPerWeek;

        private int TeacherOf(int cid) => _pb.Classes.First(c => c.Id == cid).TeacherId;

        private List<SlotCode> Domain(int cid, int teacher)
        {
            var dom = new List<SlotCode>();
            var blkClass = _pb.ClassBlock[cid];

            for (int d = 0; d < _cfg.DaysTotal; d++)
            {
                if (!ClassGapOk(_chosen[cid], d)) continue;

                for (int s = 0; s < _cfg.TimeSlots.Count; s++)
                {
                    for (int r = 0; r < _cfg.Rooms; r++)
                    {
                        var sc = SlotCode.Encode(d, s, r);
                        if (_pb.GlobalBlock.Contains(sc)) continue;
                        if (blkClass.Contains(sc)) continue;
                        if (_pb.TeacherBlock[teacher].Contains(sc)) continue;
                        if (_busyTeacher[teacher].Contains(sc)) continue;
                        if (_used.Contains(sc)) continue;
                        dom.Add(sc);
                    }
                }
            }
            return dom;
        }

        private int ConflictScore(SlotCode sc, IReadOnlyList<int> remaining)
        {
            int cnt = 0;
            foreach (var cid in remaining)
            {
                var t = TeacherOf(cid);
                if (_pb.ClassBlock[cid].Contains(sc)) continue;
                if (_busyTeacher[t].Contains(sc)) continue;
                if (_pb.TeacherBlock[t].Contains(sc)) continue;
                cnt++;
            }
            return cnt;
        }

        private bool ForwardOk(IReadOnlyList<int> rem)
        {
            foreach (var cid in rem)
            {
                var t = TeacherOf(cid);
                var dom = Domain(cid, t);
                if (dom.Count + _chosen[cid].Count < Need(cid)) return false;
            }
            return true;
        }

        private void BuildOrder(List<int> pool)
        {
            _order = pool.Select(cid =>
            {
                var t = TeacherOf(cid);
                var dsz = Domain(cid, t).Count;
                return (cid, dsz);
            })
            .OrderBy(p => p.dsz)
            .Select(p => p.cid)
            .ToList();
        }

        private bool Dfs(List<int> pool)
        {
            if (pool.Count == 0)
            {
                Best = _chosen.ToDictionary(kv => kv.Key, kv => kv.Value.ToList());
                return true;
            }

            BuildOrder(pool);
            int cid = _order[0];
            int tid = TeacherOf(cid);

            var dom = Domain(cid, tid);
            if (dom.Count + _chosen[cid].Count < Need(cid)) return false;

            var rest = pool.Where(x => x != cid).ToList();
            dom.Sort((a, b) => ConflictScore(a, rest).CompareTo(ConflictScore(b, rest)));

            foreach (var sc in dom)
            {
                _chosen[cid].Add(sc);
                _used.Add(sc);
                _busyTeacher[tid].Add(sc);

                bool done = _chosen[cid].Count == Need(cid);
                var nextPool = pool;
                if (done) nextPool = pool.Where(x => x != cid).ToList();

                if (ForwardOk(nextPool) && Dfs(nextPool)) return true;

                _chosen[cid].RemoveAt(_chosen[cid].Count - 1);
                _used.Remove(sc);
                _busyTeacher[tid].Remove(sc);
            }
            return false;
        }
    }

    // ===== Helpers: dựng block từ “danh sách slot cho phép” theo DOW =====
    public static class BlockBuilder
    {
        // tạo GlobalBlock bằng cách khóa tất cả slot KHÔNG thuộc “allowedByDow”
        // allowedByDow: key = dow(0..6), value = danh sách slotIdx cho phép
        public static void ApplyGlobalBlocksFromAllowed(
            Problem pb, Config cfg, Dictionary<int, HashSet<int>> allowedByDow)
        {
            for (int d = 0; d < cfg.DaysTotal; d++)
            {
                int dow = (cfg.StartDow + d) % 7;
                var allowed = allowedByDow.TryGetValue(dow, out var set) ? set : new HashSet<int>();
                for (int s = 0; s < cfg.TimeSlots.Count; s++)
                {
                    bool ok = allowed.Contains(s);
                    if (!ok)
                    {
                        for (int r = 0; r < cfg.Rooms; r++)
                            pb.GlobalBlock.Add(SlotCode.Encode(d, s, r));
                    }
                }
            }
        }

        // tạo block cho giáo viên theo DOW + slot cho phép (nếu cần)
        public static void ApplyTeacherAllowed(
            Problem pb, Config cfg, int teacherId, Dictionary<int, HashSet<int>> allowedByDow)
        {
            if (!pb.TeacherBlock.ContainsKey(teacherId)) pb.TeacherBlock[teacherId] = new HashSet<SlotCode>();
            var blk = pb.TeacherBlock[teacherId];

            for (int d = 0; d < cfg.DaysTotal; d++)
            {
                int dow = (cfg.StartDow + d) % 7;
                var allowed = allowedByDow.TryGetValue(dow, out var set) ? set : new HashSet<int>();
                for (int s = 0; s < cfg.TimeSlots.Count; s++)
                {
                    bool ok = allowed.Contains(s);
                    if (!ok)
                    {
                        for (int r = 0; r < cfg.Rooms; r++)
                            blk.Add(SlotCode.Encode(d, s, r));
                    }
                }
            }
        }
    }

    // ===== Program (3 test cases) =====
    public static class Program
    {
        public static void Main()
        {
            Console.OutputEncoding = System.Text.Encoding.UTF8;

            // TimeSlots (khớp DB)
            var timeSlots = new List<TimeSlotDef>
            {
                new() { SlotId = 0, Label = "07-09", Start = new(7,0), End = new(9,0) },
                new() { SlotId = 1, Label = "09-11", Start = new(9,0), End = new(11,0) },
                new() { SlotId = 2, Label = "13-15", Start = new(13,0), End = new(15,0) },
                new() { SlotId = 3, Label = "15-17", Start = new(15,0), End = new(17,0) },
                new() { SlotId = 4, Label = "17-19", Start = new(17,0), End = new(19,0) },
                new() { SlotId = 5, Label = "19-21", Start = new(19,0), End = new(21,0) },
            };

            // ======= TEST CASE 1 =======
            Console.WriteLine("=== TEST CASE 1: 1 room, 1 teacher, 8 classes, 1 week (MinGap=2) ===");
            var cfg1 = new Config
            {
                TimeSlots = timeSlots,
                Rooms = 1,
                DaysTotal = 7,
                StartDow = 0, // Monday
                MinGapDays = 2,
                StartDate = new DateOnly(2025, 10, 06)
            };

            var classes1 = new List<ClassInfo>();
            for (int i = 1; i <= 8; i++) classes1.Add(new ClassInfo { Id = i, SessionsPerWeek = 2, TeacherId = 1 });

            var pb1 = new Problem { Classes = classes1 };

            var allowedByDow1 = new Dictionary<int, HashSet<int>>
            {
                // Mon..Sat: only 17-19(4), 19-21(5)
                { 0, new HashSet<int>{4,5} }, { 1, new HashSet<int>{4,5} }, { 2, new HashSet<int>{4,5} },
                { 3, new HashSet<int>{4,5} }, { 4, new HashSet<int>{4,5} }, { 5, new HashSet<int>{4,5} },
                // Sun: 07-09(0), 09-11(1), 15-17(3), 17-19(4), 19-21(5)
                { 6, new HashSet<int>{0,1,3,4,5} }
            };
            BlockBuilder.ApplyGlobalBlocksFromAllowed(pb1, cfg1, allowedByDow1);

            var result1 = RunAndPrint("CASE 1", cfg1, pb1);
            Console.WriteLine();

            // ======= TEST CASE 2 =======
            Console.WriteLine("=== TEST CASE 2: 4 weeks, 4 rooms, 10 classes / 3 teachers (MinGap=2) ===");
            var cfg2 = new Config
            {
                TimeSlots = timeSlots,
                Rooms = 4,
                DaysTotal = 28, // 4 weeks
                StartDow = 0,
                MinGapDays = 2,
                StartDate = new DateOnly(2025, 10, 06)
            };

            var classes2 = new List<ClassInfo>();
            for (int i = 1; i <= 10; i++)
            {
                int teacher = (i % 3) + 1; // 1..3
                classes2.Add(new ClassInfo { Id = i, SessionsPerWeek = 3, TeacherId = teacher });
            }
            var pb2 = new Problem { Classes = classes2 };

            // Teacher 2 bận Wed(2) slot 1 mỗi tuần; Teacher 3 bận Fri(4) slot 0 mỗi tuần
            var teacher2Allowed = new Dictionary<int, HashSet<int>>
            {
                { 2, new HashSet<int>{0,2,3,4,5} } // cho phép mọi slot trừ 1
            };
            var teacher3Allowed = new Dictionary<int, HashSet<int>>
            {
                { 4, new HashSet<int>{1,2,3,4,5} } // cho phép mọi slot trừ 0
            };
            BlockBuilder.ApplyTeacherAllowed(pb2, cfg2, 2, teacher2Allowed);
            BlockBuilder.ApplyTeacherAllowed(pb2, cfg2, 3, teacher3Allowed);

            var result2 = RunAndPrint("CASE 2", cfg2, pb2);
            Console.WriteLine();

            // ======= TEST CASE 3 =======
            Console.WriteLine("=== TEST CASE 3: 1 room, 3 teachers, 6 classes, custom blocks (MinGap=2) ===");
            var cfg3 = new Config
            {
                TimeSlots = timeSlots,
                Rooms = 1,
                DaysTotal = 14, // 2 weeks
                StartDow = 1,   // Tuesday
                MinGapDays = 2,
                StartDate = new DateOnly(2025, 10, 07)
            };
            var classes3 = new List<ClassInfo>
            {
                new() { Id = 1, SessionsPerWeek = 2, TeacherId = 10 },
                new() { Id = 2, SessionsPerWeek = 2, TeacherId = 10 },
                new() { Id = 3, SessionsPerWeek = 2, TeacherId = 11 },
                new() { Id = 4, SessionsPerWeek = 2, TeacherId = 11 },
                new() { Id = 5, SessionsPerWeek = 2, TeacherId = 12 },
                new() { Id = 6, SessionsPerWeek = 2, TeacherId = 12 },
            };
            var pb3 = new Problem { Classes = classes3 };

            // Global: khóa toàn bộ slot 0 và 1 cho mọi ngày (chỉ học từ chiều tối)
            for (int d = 0; d < cfg3.DaysTotal; d++)
                for (int r = 0; r < cfg3.Rooms; r++)
                {
                    pb3.GlobalBlock.Add(SlotCode.Encode(d, 0, r));
                    pb3.GlobalBlock.Add(SlotCode.Encode(d, 1, r));
                }

            // Class 1 bị block slot 4 toàn bộ (không học 17-19)
            pb3.ClassBlock[1] = new HashSet<SlotCode>();
            for (int d = 0; d < cfg3.DaysTotal; d++)
                pb3.ClassBlock[1].Add(SlotCode.Encode(d, 4, 0));

            // Teacher 12 không dạy Chủ nhật (dow=6) mọi slot
            pb3.TeacherBlock[12] = new HashSet<SlotCode>();
            for (int d = 0; d < cfg3.DaysTotal; d++)
            {
                int dow = (cfg3.StartDow + d) % 7;
                if (dow == 6)
                    for (int s = 0; s < cfg3.TimeSlots.Count; s++)
                        pb3.TeacherBlock[12].Add(SlotCode.Encode(d, s, 0));
            }

            var result3 = RunAndPrint("CASE 3", cfg3, pb3);
            Console.WriteLine();

            // In tóm tắt pass/fail ba case
            Console.WriteLine("SUMMARY:");
            Console.WriteLine($"Case1: {(result1 ? "OK" : "FAIL")}");
            Console.WriteLine($"Case2: {(result2 ? "OK" : "FAIL")}");
            Console.WriteLine($"Case3: {(result3 ? "OK" : "FAIL")}");
        }

        private static bool RunAndPrint(string title, Config cfg, Problem pb)
        {
            var sch = new Scheduler(cfg, pb);
            var ok = sch.Solve();

            if (!ok)
            {
                Console.WriteLine($"[{title}] Không lập được lịch.");
                return false;
            }

            // Giả lập RoomId/RoomName từ room index
            Guid RoomGuidOf(int roomIdx) => GuidUtility.Create(GuidUtility.UrlNamespace, $"room-{roomIdx + 1}");
            string RoomNameOf(int roomIdx) => $"Room {roomIdx + 1}";

            // Chuyển Best -> ScheduleRows (khớp DB ClassSchedules)
            var rows = new List<ScheduleRow>();
            foreach (var (cid, slots) in sch.Best.OrderBy(k => k.Key))
            {
                foreach (var sc in slots.OrderBy(s => s.DayIdx).ThenBy(s => s.SlotIdx))
                {
                    var ts = cfg.TimeSlots[sc.SlotIdx];
                    rows.Add(new ScheduleRow
                    {
                        ClassId = cid,
                        SessionDate = cfg.StartDate.AddDays(sc.DayIdx),
                        SlotId = ts.SlotId,
                        RoomId = RoomGuidOf(sc.Room),
                        IsAutoGenerated = true,
                        StartTime = ts.Start,
                        EndTime = ts.End,
                        RoomName = RoomNameOf(sc.Room)
                    });
                }
            }

            Console.WriteLine($"[{title}] Lập lịch thành công. Tổng buổi: {rows.Count}");
            foreach (var g in rows.GroupBy(r => r.ClassId).OrderBy(g => g.Key))
            {
                Console.WriteLine($"  Lớp {g.Key}:");
                foreach (var r in g)
                    Console.WriteLine($"    • {r.SessionDate:yyyy-MM-dd}  Slot#{r.SlotId} ({r.StartTime}-{r.EndTime})  {r.RoomName}");
            }
            return true;
        }
    }

    // ===== Deterministic Guid for demo (so output roomId stable) =====
    // Credit: RFC 4122 name-based UUID v5 simplified
    public static class GuidUtility
    {
        public static readonly Guid UrlNamespace = new("6ba7b811-9dad-11d1-80b4-00c04fd430c8");

        public static Guid Create(Guid namespaceId, string name)
        {
            var ns = namespaceId.ToByteArray();
            SwapByteOrder(ns);
            var nameBytes = System.Text.Encoding.UTF8.GetBytes(name);
            var data = new byte[ns.Length + nameBytes.Length];
            Buffer.BlockCopy(ns, 0, data, 0, ns.Length);
            Buffer.BlockCopy(nameBytes, 0, data, ns.Length, nameBytes.Length);
            var sha1 = System.Security.Cryptography.SHA1.HashData(data);
            var newGuid = new byte[16];
            Array.Copy(sha1, 0, newGuid, 0, 16);
            newGuid[6] = (byte)((newGuid[6] & 0x0F) | (5 << 4));  // version 5
            newGuid[8] = (byte)((newGuid[8] & 0x3F) | 0x80);      // variant
            SwapByteOrder(newGuid);
            return new Guid(newGuid);
        }

        private static void SwapByteOrder(byte[] guid)
        {
            void Swap(int a, int b) { (guid[a], guid[b]) = (guid[b], guid[a]); }
            Swap(0, 3); Swap(1, 2);
            Swap(4, 5); Swap(6, 7);
        }
    }
}
